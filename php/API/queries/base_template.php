<?php


// Generic template for Velox query definition - replace placeholder info as appropriate
// -------------------------------------------------------------------------------------
// Query definitions created with this template should remain in the same directory to be accessible by the appropriate
// API endpoint.

// Note: these classes are defined by way of the autoloader include in the API endpoint script. As such, this template is only
// intended to be used in the context of the Velox API.
use KitsuneTech\Velox\Database\Connection as Connection;
use KitsuneTech\Velox\Database\Procedures\StatementSet as StatementSet;

/*
$QUERY_VERSION should be incremented any time the result set schema changes. This will be sent as a header with the response
and allows the client-side service worker (if it exists) to update the schema of the corresponding IndexedDB instance. Per
the IndexedDB spec, version numbers must be positive integers. Normal semantic versioning doesn't apply here.
(If this variable doesn't exist or is set to 0, no IndexedDB will be generated by the service worker and the results
 will not be cached.)
*/

$QUERY_VERSION = 1;

//$conn should be either set with the appropriate values here, or better yet, should be assigned as a pre-existing connection.
$conn = $GLOBALS['VeloxConnections']['my-db-name'];
$conn = new Connection("server","database", "user", "password");

/*
$QUERIES should be adjusted to correspond to the correct queries to populate and manipulate the data in the model. Additional
custom queries can be defined in this array and called by attaching the query name as a property to the request object, having
the appropriate 'where' and 'values' criteria as necessary.

Example: to call $QUERIES['myCustomQuery'], the request object would include something like 
  myCustomQuery: {where: [{field1: ["=","something"]}], values: {field1: "something else", field2: "another value"}

The query keys specified in this template ("SELECT","UPDATE","INSERT","DELETE") have specific meaning to the implementation
of this library. Specifically, $QUERIES['SELECT'] defines the data set, and the associated Query or PreparedStatement for
$QUERIES['UPDATE'], $QUERIES['INSERT'], or $QUERIES['DELETE'] should be written in such a way as to have the equivalent effect
on that data set. If any one of these query types is not intended to be used on the data set, it may be omitted. Each of the
latter three queries, when called, is followed by a new call to $QUERIES['SELECT'] to retrieve the updated result set. If
$QUERIES['SELECT'] is not defined, no Model is generated, and any results generated by a custom query are returned directly
as a JSON-formatted array of objects in name-value pair format.

In addition to these, a primary key column name can be set in $QUERIES['PK']; if specified, the default sort will be done on
this column in ascending order. This is optional for basic single-Model query definitions, but required for nested Models,
as described below.
*/

$QUERIES = [
    'SELECT' => new StatementSet($conn, "SELECT * FROM myTable WHERE <<condition>>"),
    'UPDATE' => new StatementSet($conn, "UPDATE myTable SET <<values>> WHERE <<condition>>"),
    'INSERT' => new StatementSet($conn, "INSERT INTO myTable (<<columns>>) VALUES (<<values>>)"),
    'DELETE' => new StatementSet($conn, "DELETE FROM myTable WHERE <<condition>>"),
    'PK' => ''
];

/*
A nested Model structure can be implemented by adding a similar structure as shown above as an array element in $QUERIES
having a key name representing the column name to be assigned to the submodel. This array must also contain a 'FK' element
containing the name of the foreign key column that will be used to join on the parent Model's primary key. A 'PK' element
is optional for submodels, except if the submodel is used for further chaining.

Example:

$QUERIES = [
    'SELECT' => new StatementSet($conn, "SELECT * FROM parentTable WHERE <<condition>>"),
    'UPDATE' => new StatementSet($conn, "UPDATE parentTable SET <<values>> WHERE <<condition>>"),
    'INSERT' => new StatementSet($conn, "INSERT INTO parentTable (<<columns>>) VALUES (<<values>>)"),
    'DELETE' => new StatementSet($conn, "DELETE FROM parentTable WHERE <<condition>>"),
    'PK' => '',
    'submodel' => [
        'SELECT' => new StatementSet($conn, "SELECT * FROM childTable WHERE <<condition>>"),
        'UPDATE' => new StatementSet($conn, "UPDATE childTable SET <<values>> WHERE <<condition>>"),
        'INSERT' => new StatementSet($conn, "INSERT INTO childTable (<<columns>>) VALUES (<<values>>)"),
        'DELETE' => new StatementSet($conn, "DELETE FROM childTable WHERE <<condition>>"),
        'FK' => ''
    ]
];

Note: If any PreparedStatements are used for submodel queries, a placeholder for the foreign key column must be provided in
the WHERE clause (or on INSERT statements, in the VALUES list, with the column name specified in the column list). No such
placeholders are needed when using StatementSets; these will be automatically generated by the parent Model when the appropriate
method is called. In either case, the foreign key values will be added at that time, and need not be specified in the Diff.

*/

function postProcessing($model){
    //If any post-processing needs to be done after the model is generated but before the results are output,
    //do it here. The Model instance for this query will be assigned to the $model argument, and this function
    //will be run after the instance is generated and synchronized. This function can be omitted if no post-processing
    //is needed.
}
